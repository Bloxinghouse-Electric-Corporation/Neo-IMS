{"searchDocs":[{"title":"Introduction","type":0,"sectionRef":"#","url":"/Neo-IMS/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Design​","type":1,"pageTitle":"Introduction","url":"/Neo-IMS/docs/intro#design","content":" The Neo-IMS (Formerly RP-IMS) is a system designed to handle control and instrumentation systems in an easy to work with but efficient manner.  The Neo-IMS gives different types of devices (gauges, switches, indicators, etc.) functionality while ensuring that all scripts are kept in a centralized location and only a minimum of 2 scripts are required per device type.  Devices defined in the system can both receive input from players and display an output on a device model.  To achieve this, the Neo-IMS is divided into two sections. The Server Side and the Client Side.  The use of the Server Side include:  Storing Data about the current state of a device (i.e. position of a switch, on/off on an indicator light)Recieve and validate state change requests from the clientChange the current state when suitable and send an update to all clients  The Server Side should NOT be used for anything that the client side is responsible for.  The use of the Client Side include:  Recieving state change updates from the serverProviding visual feedback (animation) for the current state on the device model within the game worldRecieve input from the player and send them to the server for further processing  The Client Side should NOT be used for anything that the Server Side is responsible for.  ","version":"Next","tagName":"h2"},{"title":"Structure​","type":1,"pageTitle":"Introduction","url":"/Neo-IMS/docs/intro#structure","content":" ","version":"Next","tagName":"h2"},{"title":"Server Side​","type":1,"pageTitle":"Introduction","url":"/Neo-IMS/docs/intro#server-side","content":" The scripts for the Server Side are located within ServerScriptService.IMSServer and contains the following children:  Interface: This script is responsible for the following tasks: Initializing all devicesPassing references to devices to other scriptsRouting messages and signals from the client to devicesSending messages and signals from devices to the client Types: This script contains all type definitions for the different devices.Devices: This folder contains all Server Side scripts for the different devices. The ModuleScripts contained in this folder are automatically loaded by the Interface on initialization.  ","version":"Next","tagName":"h3"},{"title":"Client Side​","type":1,"pageTitle":"Introduction","url":"/Neo-IMS/docs/intro#client-side","content":" The scripts for the Client Side are located within StarterPlayer.StarterPlayerScripts.IMSClient and contains the following children:  Loader: This script is responsible for the following tasks: Initializing all devicesDeciding whether or not to load the VR version of Client Side scriptsRouting messages and signals from the server to devicesSending messages and signals from devices to the server Devices: This folder contains all Client Side scripts for the different devices. The ModuleScripts contained in this folder are automatically loaded by the Loader script on initialization. This folder also contains the subfolder “VR” for devices which require a different implementation in VR (i.e. switches and buttons) info VR Functionality is WIP! ","version":"Next","tagName":"h3"},{"title":"Device","type":0,"sectionRef":"#","url":"/Neo-IMS/api/Device","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#properties","content":" ","version":null,"tagName":"h2"},{"title":"name​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#name","content":"&lt;/&gt; Device.name: string The name of the device as it is in Workspace  ","version":null,"tagName":"h3"},{"title":"model​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#model","content":"&lt;/&gt; Device.model: Model  The model of the device in Workspace  ","version":null,"tagName":"h3"},{"title":"state​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#state","content":"&lt;/&gt; Device.state: T The current state of the device ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#functions","content":" ","version":null,"tagName":"h2"},{"title":"GetState​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#GetState","content":"&lt;/&gt; Device.GetState(self: Types.Device&lt;T&gt;) → T-- The current state of the device. Returns the current state of the device.  ","version":null,"tagName":"h3"},{"title":"SetState​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#SetState","content":"&lt;/&gt; Device.SetState( self: Types.Device&lt;T&gt;, newState: T-- The new state to set ) → boolean-- Whether or not the state change was successful. Sets the current state of the device. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device##","content":"Type\tDescription[Neo-IMS]: Device state of device [...] cannot be changed to [...].\tThe types of the old device state and the new state do not match.  ","version":null,"tagName":"h3"},{"title":"SetStateKey​","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device#SetStateKey","content":"&lt;/&gt; Device.SetStateKey( self: Types.Device&lt;T&gt;, stateKey: {[string]:any}-- The new stateKey to set ) → boolean-- Whether or not the state change was successful. Sets the current stateKey (substate) of the device. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Device","url":"/Neo-IMS/api/Device##","content":"Type\tDescription[Neo-IMS]: Cannot set StateKey of device [...] because its state is not a table.\tIf the device was not initialized with a Complex State you cannot set a substate. [Neo-IMS]: Key passed to Device:SetStateKey for device [...] is nil.\tA value was passed with a nil key. [Neo-IMS]: Failed to find statekey [...] of device [...].\tAttempted to set a StateKey which does not exist on the device. ","version":null,"tagName":"h3"},{"title":"Workspace Definition","type":0,"sectionRef":"#","url":"/Neo-IMS/docs/definition","content":"","keywords":"","version":"Next"},{"title":"Tagging​","type":1,"pageTitle":"Workspace Definition","url":"/Neo-IMS/docs/definition#tagging","content":" Once you have the device modules scripted, you still need to ensure that the Neo-IMS knows which models to treat as that device.  Doing this is also pretty simple.  Simply add a CollectionService tag to the device model named the exact same thing as the module scripts for the device.  Once you do this, Neo-IMS loads an instance of that device for each tagged model.  ","version":"Next","tagName":"h2"},{"title":"Initial States​","type":1,"pageTitle":"Workspace Definition","url":"/Neo-IMS/docs/definition#initial-states","content":" To define an initial state, simply add a value object to the root of your device model named InitialState (Case Sensitive) to define a Basic State.  Alternatively, add a folder to the root of your device model named InitialState to define a Complex State. This folder contains the value objects for the complex state.  note Subfolders are currently not supported. ","version":"Next","tagName":"h2"},{"title":"Client Side Programming","type":0,"sectionRef":"#","url":"/Neo-IMS/docs/programmingc","content":"","keywords":"","version":"Next"},{"title":"Device Initialization​","type":1,"pageTitle":"Client Side Programming","url":"/Neo-IMS/docs/programmingc#device-initialization","content":" Client Side device modules are stored within the StarterPlayer.StarterPlayerScripts.IMSClient.Devices(.VR) folder. These modules are automatically loaded by the system as explained in Introduction.  The most basic form of a client module looks like this:  StarterPlayer.StarterPlayerScripts.IMSClient.Devices.Test local module = {} function module.Init(deviceModel:Model, deviceState:boolean) -- change this type to match your device end function module.Update(deviceModel:Model, deviceState:boolean) -- change this type to match your device end return module   The Init function runs once when the device gets initialized.  The Update function runs every time the state of the device updates on the server.  The deviceModel parameter can be used to visually update (animate) the device's model in accordance with the state.  The programmer is responsible for any further handling of logic.  ","version":"Next","tagName":"h2"},{"title":"Manipulating the State​","type":1,"pageTitle":"Client Side Programming","url":"/Neo-IMS/docs/programmingc#manipulating-the-state","content":" To request a state change to the server, the remote event in ReplicatedStorage.IMSShared.SendDeviceMessage can be used.  In this remote event, the device's name (this can be done using deviceModel.Name), and the message you wish to pass should be passed.  An example call to this remote event looks like this:  local repStor = game:GetService(&quot;ReplicatedStorage&quot;) function module.Init(deviceModel:Model, deviceState:boolean) repStor.IMSShared.SendDeviceMessage:FireServer(deviceModel.Name, {[&quot;messageKey&quot;]:&quot;messageValue&quot;}) end  ","version":"Next","tagName":"h2"},{"title":"Types","type":0,"sectionRef":"#","url":"/Neo-IMS/api/Types","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Types","url":"/Neo-IMS/api/Types#types","content":" ","version":null,"tagName":"h2"},{"title":"Device<T>​","type":1,"pageTitle":"Types","url":"/Neo-IMS/api/Types#Device<T>","content":"&lt;/&gt; interface Device&lt;T&gt; { name: string model: Model className: string state: T GetState: (self:Types.Device&lt;T&gt;) → T SetState: ( self:Types.Device&lt;T&gt;, state:T ) → boolean SetStateKey: ( self:Types.Device&lt;T&gt;, stateKey: {[string]:any} ) → boolean RevieveMessage: ( self:Types.Device&lt;T&gt;, player:Player, msg: {[string]:any} ) → boolean OnStateChanged: signal OnStateKeyChanged: signal OnMessageRecieved: signal }  ","version":null,"tagName":"h3"},{"title":"Interface","type":0,"sectionRef":"#","url":"/Neo-IMS/api/Interface","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Interface","url":"/Neo-IMS/api/Interface#functions","content":" ","version":null,"tagName":"h2"},{"title":"Version​","type":1,"pageTitle":"Interface","url":"/Neo-IMS/api/Interface#Version","content":"&lt;/&gt; Interface.Version() → string-- Returns the current version of Neo-IMS Returns the current version of Neo-IMS as a string.  ","version":null,"tagName":"h3"},{"title":"Init​","type":1,"pageTitle":"Interface","url":"/Neo-IMS/api/Interface#Init","content":"&lt;/&gt; Interface.Init() → () Initializes Neo-IMS and loads all devices tagged with a valid class name. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Interface","url":"/Neo-IMS/api/Interface##","content":"Type\tDescription[Neo-IMS]: Failed to find signal library under 'ReplicatedStorage.Signal'.\tThis error is thrown if you failed to provide a signal library for Neo-IMS to use. [Neo-IMS]: 'ReplicatedStorage.Signal' is not a module script!\tNeo-IMS expects a signal library that has a single module script as an interface. [Neo-IMS]: Device with name [...] already exists. Skipping.\tNeo-IMS cannot load multiple devices with the same name. Only one instance will be loaded.  ","version":null,"tagName":"h3"},{"title":"GetDevice​","type":1,"pageTitle":"Interface","url":"/Neo-IMS/api/Interface#GetDevice","content":"&lt;/&gt; Interface.GetDevice( name: string-- The name of the device as it is in workspace. ) → Types.Device&lt;any&gt; | nil-- The instance of the device, or nil if it does not exist. Returns an instance of a device if it exists.  ","version":null,"tagName":"h3"},{"title":"GetDevicesOfClass​","type":1,"pageTitle":"Interface","url":"/Neo-IMS/api/Interface#GetDevicesOfClass","content":"&lt;/&gt; Interface.GetDevicesOfClass( class: string-- The class to look for ) → {Types.Device&lt;any&gt;}-- The array of devices Returns a table of all devices of a certain class. ","version":null,"tagName":"h3"},{"title":"Server Side Programming","type":0,"sectionRef":"#","url":"/Neo-IMS/docs/programmings","content":"","keywords":"","version":"Next"},{"title":"Device Initialization​","type":1,"pageTitle":"Server Side Programming","url":"/Neo-IMS/docs/programmings#device-initialization","content":" Server Side device modules are stored within the ServerScriptService.IMSServer.Devices folder. These modules are automatically loaded by the system as explained in Introduction.  The most basic form of a server module looks like this:  ServerScriptService.IMSServer.Devices.Test local types = require(script.Parent.Parent.Types) local device = require(script.Parent.Bases.Device) local Module = {} Module.__index = Module setmetatable(Module, device) function Module.new(model:Model, initialState:boolean):types.Device&lt;boolean&gt; -- update &quot;boolean&quot; here to the correct type if initialState ~= nil and type(initialState) ~= &quot;boolean&quot; then -- update &quot;boolean&quot; here to the correct type error(&quot;[INTERACTION SYSTEM]: InitialState type for Module must be boolean!&quot;) -- update &quot;boolean&quot; here to the correct type return nil end local self = device.new(model, initialState or false) -- &quot;false&quot; is the default value setmetatable(self, Module) return self end return Module   The code above does the following in order: When the module gets initialized by the Interface:  Ensure the initial state passed by the Interface is a valid type for this device or if it is nil, throw and error if it is neither.Instantiate the base device class with the physical device model in the game world and the initial state or set it to a default value if initialState is nil.Return a reference to the device.  note Most of the time, this default initialization code does NOT need to be altered aside from changing the types and default value to match your device. In future versions of Neo-IMS we plan on simplifying this by providing a default init function.  This Module.new() function is the only requirement for a valid server side script. The programmer is responsible for further event handling themselves. (Examples are covered later in the docs.)  ","version":"Next","tagName":"h2"},{"title":"Referencing​","type":1,"pageTitle":"Server Side Programming","url":"/Neo-IMS/docs/programmings#referencing","content":" To get a reference to a device on the server for usage in other scripts (i.e. within the simulation), the Interface.GetDevice(name) function is used.  The name of the model in workspace must be passed to this function. If the device exists, a reference to it will be returned, otherwise the Interface will return nil.If multiple devices of the same name exist, only one of them will be functional.  Example of requesting a device reference:  ServerScriptService.TestDevice local ims = require(script.Parent.IMSServer.Interface) local device = ims.GetDevice(&quot;myDevice&quot;)   The reference to the device &quot;myDevice&quot; is now stored in the device variable and can be used for further processing. (i.e. getting/setting the state.)  important The Interface.GetDevice() function should only be called once per device and the reference should be saved in a variable!  ","version":"Next","tagName":"h2"},{"title":"Manipulating the State​","type":1,"pageTitle":"Server Side Programming","url":"/Neo-IMS/docs/programmings#manipulating-the-state","content":" Every device defined in the Neo-IMS system has a State.  Examples for a state would be:  The currently selected position on a switchWhether or not a button is currently depressedWhether or not an indicator light is currently lit  A state can be any type which exists as a Value Object. This means all of the following types are valid:  BooleanBrickColorCFrameColor3IntNumberObjectRayStringVector3    A state that is only made up of one value is refered to as a Basic State.  The Neo-IMS makes manipulating a Basic State very simple.  In this example we will imagine an indicator light stored in a variable named &quot;indicator&quot;. For a simple indicator light the state is a boolean.  To Set the state of the indicator, you would do the following:  ServerScriptService.IndicatorTest local indicator = ims.GetDevice(&quot;myIndicator&quot;) indicator:SetState(true)   To Get the state of the indicator, you would do the following:  ServerScriptService.IndicatorTest local indicator = ims.GetDevice(&quot;myIndicator&quot;) local value = indicator:GetState() -- alternative - both do the same thing local value = indicator.state   It is also possible to Subscribe to a state change event:  ServerScriptService.IndicatorTest local indicator = ims.GetDevice(&quot;myIndicator&quot;) indicator.OnStateChanged:Connect(function(state) -- your code here end)     In addition to Basic States, it is also possble to combine multiple values into one state. This is called a Complex State  Complex States are a table which contains multiple different StateKeys (or alternatively, Substates)  As an example for Setting a Complex State, we will use a traffic light. Traffic lights have three individual lights. This means the state is made up of three booleans named red, yellow, and green.  If we were to use trafficlight:SetState() from above, we would need to pass a table containing all three values and the existing state would be replaced. Most of the time, this is not what you want. Instead you can do the following:  Say we want to turn on only the green light, but leave the remaining two lights how they were.  ServerScriptService.TrafficLightTest local trafficlight = ims.GetDevice(&quot;TrafficLight&quot;) indicator:SetStateKey({green = true}) -- This will only affect the green light, yellow and red will stay as they are.   If you pass multiple keys into this function, they will also be affected.  ServerScriptService.TrafficLightTest local trafficlight = ims.GetDevice(&quot;TrafficLight&quot;) indicator:SetStateKey({green = true, yellow = true}) -- Yellow and green will turn on, red will stay as it was.   To Get a complex state, the same functions as the Basic State can be used as they will just return a table.  ","version":"Next","tagName":"h2"},{"title":"Recieving Messages​","type":1,"pageTitle":"Server Side Programming","url":"/Neo-IMS/docs/programmings#recieving-messages","content":" Messages are data sent by the client to request the server to do something. This could for example be the user clicking on a button.  A client message is made up of a table and handling these messages is up to the programmer.  To handle a message, add the following to your device's server module:  ServerScriptService.IMSServer.Devices.MyDevice function Module.RecieveMessage(self:types.Device&lt;boolean&gt;, player:Player, msg:{[string]:any}):boolean -- message handling code end   This function needs to return either true or false depending on whether or not handling the message was successful.  warning Neo-IMS by default does not provide any exploit protection for message handling. You are required to implement this yourself. ","version":"Next","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/Neo-IMS/docs/examples","content":"","keywords":"","version":"Next"},{"title":"Indicator Light​","type":1,"pageTitle":"Examples","url":"/Neo-IMS/docs/examples#indicator-light","content":" ","version":"Next","tagName":"h2"},{"title":"Server Side​","type":1,"pageTitle":"Examples","url":"/Neo-IMS/docs/examples#server-side","content":" An indicator light only requires the basic server side script. The state is a Basic State of type boolean.  ServerScriptService.IMSServer.Device.Indicator local types = require(script.Parent.Parent.Types) local device = require(script.Parent.Bases.Device) local Module = {} Module.__index = Module setmetatable(Module, device) function Module.new(model:Model, initialState:boolean):types.Device&lt;boolean&gt; if initialState ~= nil and type(initialState) ~= &quot;boolean&quot; then error(&quot;[INTERACTION SYSTEM]: InitialState type for Indicator must be boolean!&quot;) return nil end local self = device.new(model, initialState or false) -- &quot;false&quot; is the default value setmetatable(self, Module) return self end return Module   ","version":"Next","tagName":"h3"},{"title":"Client Side​","type":1,"pageTitle":"Examples","url":"/Neo-IMS/docs/examples#client-side","content":" The client side is also very simple. On an update, the light's material will get set to neon or glass depending on whether or not the state is set to true.  StarterPlayer.StarterPlayerScripts.IMSClient.Devices.Indicator local module = {} function module.Init(deviceModel:Model, deviceState:boolean) -- Run update to ensure the initial device state gets displayed correctly module.Update(deviceModel, deviceState) end function module.Update(deviceModel:Model, deviceState:boolean) deviceModel.light.Material = deviceState and Enum.Material.Neon or Enum.Material.Glass end return module     ","version":"Next","tagName":"h3"},{"title":"Button​","type":1,"pageTitle":"Examples","url":"/Neo-IMS/docs/examples#button","content":" ","version":"Next","tagName":"h2"},{"title":"Server Side​","type":1,"pageTitle":"Examples","url":"/Neo-IMS/docs/examples#server-side-1","content":" Whenever the server recievs a message from the client, it updates the state accordingly:  ServerScriptService.IMSServer.Device.Button local types = require(script.Parent.Parent.Types) local device = require(script.Parent.Bases.Device) local signal = require(game:GetService(&quot;ReplicatedStorage&quot;).Signal) local Module = {} Module.__index = Module setmetatable(Module, device) function Module.new(model:Model, initialState:boolean):types.Device&lt;boolean&gt; -- Standard init function end function Module.RecieveMessage(self:types.Device&lt;boolean&gt;, player:Player, msg:{[string]:any}):boolean if msg[&quot;EVENT&quot;] == &quot;click&quot; then self:SetState(true) return true -- message was processed successfully elseif msg[&quot;EVENT&quot;] == &quot;release&quot; then self:SetState(false) return true -- message was processed successfully end return false -- message was not processed successfully end return Module   ","version":"Next","tagName":"h3"},{"title":"Client Side​","type":1,"pageTitle":"Examples","url":"/Neo-IMS/docs/examples#client-side-1","content":" The client sends a message whenever the player clicks or releases the button and updates the model (by changing the button material) according to the device state.  StarterPlayer.StarterPlayerScripts.IMSClient.Devices.Button local repStor = game:GetService(&quot;ReplicatedStorage&quot;) local module = {} function module.Init(deviceModel:Model, deviceState:boolean) deviceModel:WaitForChild(&quot;Button&quot;).DragDetector.DragStart:Connect(function() repStor.IMSShared.SendDeviceMessage:FireServer(deviceModel.Name, {[&quot;EVENT&quot;]=&quot;click&quot;}) end) deviceModel:WaitForChild(&quot;Button&quot;).DragDetector.DragEbd:Connect(function() repStor.IMSShared.SendDeviceMessage:FireServer(deviceModel.Name, {[&quot;EVENT&quot;]=&quot;release&quot;}) end) end function module.Update(deviceModel:Model, deviceState:boolean) local button = deviceModel:WaitForChild(&quot;Button&quot;) if deviceState == true then button.Material = Enum.Material.Neon else button.Material = Enum.Material.SmoothPlastic end end return module  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}